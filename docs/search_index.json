[
["r-start.html", "10 Einstieg in R 10.1 Vorbereitung", " 10 Einstieg in R Unterlagen für die Einführung in R, Proseminar-Level. (c) Clau Dermont, Institut für Politikwissenschaft, Universität Bern. Basierend auf: Wickham, Hadley &amp; Garrett Golemund. R for Data Science. O’Reilly. R for Data Science Weitere Möglichkeiten, um sich selbständig in R einzuarbeiten: Try R, ein Tutorial für die Grundsätze der R-Sprache, Beginners’ Guide to R, einfache Einführung, Cookbook, verschiedene weiterführende Tutorials, RDDJ, Ressourcen für Datenjournalismus mit R, R Vis, weiterführender Kurs in Datenvisualisierungen. 10.1 Vorbereitung Bitte die aktuellste Version von R (3.4.2) vorgänglich installieren, zusätzlich empfiehlt sich RStudio als Oberfläche zur Arbeit mit R. Diese Einführung geht davon aus, dass RStudio genutzt wird. Einer der Vorteile an RStudio ist, dass wir auf einem Bildschirm die verschiedenen Kacheln/Panes haben: Links oben “Source”, links unten die “Console”, rechts oben das “Environment”, und rechts unten meist die “Files” oder die “Plots”. Anders als in R ist die gesamte Arbeitsumgebung aufgeräumert. Die vier Panes können übrigens frei angeordnet werden, ich bevorzuge die Konsole auf der rechten Seite zu haben, sodass sich Source und Console nicht im Platz konkurrenzieren. Vom Arbeitsprozedere ist es sinnvoll, seine Scripte immer in einem R-Scriptfile abzuspeichern (entspricht einem do-File in Stata). In diesem Script wird gearbeitet, und anschliessend werden die Codeabschnitte in der Konsole ausprobiert. Neben rüberkopieren gibt es übrigens auch die Möglichkeit, per Ctrl+Enter ausgewählten Code automatisch laufen zu lassen. Alle weiteren Shortcuts sind per Alt+Shift+K zu finden. Um RStudio parat für die Arbeit zu haben, installieren wir zusätzlich die Package tidyverse. Neben den Grundbefehlen von R vereinfacht das “Tidyverse” verschiedene Schritte der Datenaufbereitung, -säuberung, und -darstellung. # Einmalig nach der Installation von R install.packages(&quot;tidyverse&quot;) Bei jeder Sitzung von R werden wir anschliessend die Arbeitsumgebung vorbereiten. Dafür laden wir die Package tidyverse (jedesmal) und definieren, wo unsere Daten zu finden sind. Zur Vorbereitung ladet ihr die auf ILIAS zur Verfügung gestellten Unterlagen runter, und speichert die in einem Ordner. Diesen Ordner definiert ihr jetzt als Arbeitsumgebung mit setwd() oder per Menü-Auswahl. # Jedesmal beim Aufstarten von R # Package laden library(tidyverse) # Pfad setzen wd &lt;- &quot;~/Pfad/zu/eurem/Ordner/&quot; # darauf achten, dass R keine \\ versteht setwd(wd) In RStudio kann der Pfad auch per Menü ausgewählt werden: Session &gt; Set Working Directory &gt; Choose Directory. Oder per Shortcut: Ctrl+Shift+H Die drei wichtigsten Packages im Tidyverse sind tidyr und dplyr für die Datensäuberung sowie ggplot2 für Visualisierungen. RStudio bietet auch Cheatsheets für diese Packages an, d.h., eine Übersicht der Befehle. Diese finden sich im Menü Help &gt; Cheatsheets. Alternativ kann man bei allen Befehlen von R in der Konsole direkt den Befehl ?ggplot2 reinschreiben, und R wird einem die Hilfeseite für diese Funktion oder Package öffnen. "],
["datenanalyse.html", "11 Datenanalyse 11.1 Daten anschauen 11.2 Daten vergleichen", " 11 Datenanalyse 11.1 Daten anschauen Politikwissenschaft hat in vielen Fällen mit Daten zu tun. Umfragen, statistische Erhebungen der Bevölkerung, Anzahl abgestimmte Initiativen und Referenden, Abstimmungsverhalten in Parlamenten, Netzwerke von politischen Akteuren - alle diese Daten verlangen nach einer Auswertung und intuitiv zugänglichen Resultaten, welche ermöglichen, die Daten zu interpretieren und zu verstehen. Die Analyse von Daten bedeutet in vielen Fällen zuerst einmal die mühsame Aufbereitung von Daten. Nach diesem ersten Schritt ist es aber möglich, mit relativ einfachen Mitteln die Daten tatsächlich anzuschauen und zu interpretieren. Für einen ersten Einstieg in R werden wir die Aufbereitung von Daten zuerst überspringen, und zuerst die Daten direkt anschauen. Für diese erste Einführung nutzen wir Daten der VOTO-Studien, d.h. eine Umfrage mit Individualdaten. Diese Daten sind im Uninetz verfügbar. Hier laden wir die Daten zur Abstimmung vom 21. Mai 2017 in R rein, das heisst zur Abstimmung zum Energiegesetz (Energiestrategie 2050). Aus den gesamten Daten bearbeiten wir einen Sample von 200 Beobachtungen und 23 Variablen. Den gesamten Fragebogen findet ihr ebenfalls auf der Webseite von VOTO oder auf ILIAS. # Der Befehl read.table gibt an, welche Datei geladen werden soll, # und speichert das Resultat in ein R-Objekt mit dem Namen &quot;voto&quot; ab voto &lt;- read.table(&quot;voto855_sample.csv&quot;, header=T, sep=&quot;;&quot;, stringsAsFactors = F, fileEncoding=&quot;UTF-8&quot;) # Dieser Befehl funktioniert nur, indem der richtige Pfad zur Datei angegeben # wird, wenn er also scheitert, kontrollieren dass diese Datei auch im &quot;wd&quot; ist Sobald die Daten eingelesen sind, sollten wir diese anschauen, damit wir auch wissen, dass alles korrekt geklappt hat - und wenn es unbekannte Daten sind, um diese kennen zu lernen. Diese reingeladenen Daten können wir jetzt anschauen, indem wir den Objektnamen voto referenzieren. R kann viele Objekte - Datenframes, Vektoren, Matrizen, Werte, Funktionen - im sogenannten Environment haben (in RStudio ist eine der vier Kacheln eine Übersicht des Environments). Deshalb ist es wichtig (im Vergleich bspw. zu Stata) immer zu referenzieren, welchen Datensatz oder Vektor man anschauen möchte. # Den gesamten Datensatz in der Konsole anzeigen (wird nicht durchgeführt) voto # Ähnlich wie der edit-Befehl in Stata ist View() View(voto) # Nur die ersten sechs Linien und die ersten zehn Variablen head(voto[,1:10]) ## personid_4 polint part ## 1 86554 2 rather interested 1 participated ## 2 27124 1 very interested 1 participated ## 3 93625 3 rather not interested 1 participated ## 4 17071 2 rather interested 1 participated ## 5 92524 2 rather interested 2 did not participate ## 6 27713 3 rather not interested 1 participated ## titel_1 vote_1 ## 1 1 Energy Act mentioned 1 yes (accepted) ## 2 1 Energy Act mentioned 1 yes (accepted) ## 3 1 Energy Act mentioned 1 yes (accepted) ## 4 1 Energy Act mentioned 2 no (rejected) ## 5 0 Energy Act not mentioned ## 6 1 Energy Act mentioned 1 yes (accepted) ## party trust_1 importance1 ## 1 03 FDP - FDP.The Liberals 09 06 ## 2 04 CVP - Christian Democratic Party 10 complete trust 09 ## 3 96 does not affiliate with a party 05 05 ## 4 98 don&#39;t know 08 07 ## 5 96 does not affiliate with a party 03 ## 6 04 CVP - Christian Democratic Party 08 08 ## value3 value11 ## 1 3 rather agree with 1st statement 6 completely agree with 2nd statement ## 2 4 rather agree with 2nd statement 6 completely agree with 2nd statement ## 3 4 rather agree with 2nd statement 5 agree with 2nd statement ## 4 2 agree with 1st statement 4 rather agree with 2nd statement ## 5 8 don&#39;t know 4 rather agree with 2nd statement ## 6 2 agree with 1st statement 6 completely agree with 2nd statement # Nur die Variablennamen colnames(voto) ## [1] &quot;personid_4&quot; &quot;polint&quot; &quot;part&quot; ## [4] &quot;titel_1&quot; &quot;vote_1&quot; &quot;party&quot; ## [7] &quot;trust_1&quot; &quot;importance1&quot; &quot;value3&quot; ## [10] &quot;value11&quot; &quot;difficul1&quot; &quot;vote2&quot; ## [13] &quot;part2&quot; &quot;educ&quot; &quot;acti&quot; ## [16] &quot;income&quot; &quot;sex&quot; &quot;birthyear&quot; ## [19] &quot;birthmonth&quot; &quot;maritalstatus&quot; &quot;reportingcanton&quot; ## [22] &quot;communelanguage&quot; &quot;lrsp&quot; # Wollen wir Zusammenfassungen sehen, können wir summary() verwenden # Dies funktioniert für den gesamten Datensatz oder nur für eine Variable summary(voto$birthyear) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1927 1948 1962 1963 1975 1999 # table() zeigt die Werte einer Variable an table(voto$vote_1) ## ## 1 yes (accepted) 2 no (rejected) 8 don&#39;t know ## 70 95 30 2 ## 9 no answer ## 3 11.2 Daten vergleichen Dieses Kapitel folgt in etwa Chapter 1 des Buches R for Data Science Interessanter wird es aber, wenn wir nicht nur einzelne Variablen anschauen, sondern zwei oder mehrere miteinander vergleichen. Beispielsweise könnten wir mit diesen Daten der Frage auf den Grund gehen, wie Alter, Geschlecht und Partizipation zusammenhängen - nehmen jüngere Stimmberechtigte und Frauen tatsächlich weniger of an Abstimmungen teil? Folgende Variablen kommen dafür zum Einsatz: das Alter erfahren wir über das Geburtsjahr birthyear, das Geschlecht ist in der Variable sex gespeichert, die Partizipationsvariable part beschreibt, ob eine Person am 21. Mai 2017 teilgenommen hat, zusätzlich wissen wir über part2, wie oft eine Person im Schnitt bei zehn Abstimmungen teilnimmt. Schauen wir uns diese Variablen einmal genauer an. head(select(voto, birthyear, part, part2, sex)) ## birthyear part part2 sex ## 1 1997 1 participated 10 10 votings 1 man ## 2 1967 1 participated 10 10 votings 1 man ## 3 1948 1 participated 07 2 woman ## 4 1998 1 participated 10 10 votings 2 woman ## 5 1963 2 did not participate 04 2 woman ## 6 1948 1 participated 10 10 votings 2 woman # Geburtsjahr summary(voto$birthyear) ## Min. 1st Qu. Median Mean 3rd Qu. Max. ## 1927 1948 1962 1963 1975 1999 table(voto$birthyear) ## ## 1927 1928 1929 1930 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 ## 1 1 1 2 2 2 2 3 3 2 3 2 4 2 4 ## 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 ## 3 3 5 6 7 6 2 4 2 3 3 2 4 1 3 ## 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 ## 4 4 7 6 4 2 4 3 2 1 5 4 3 7 4 ## 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1990 1991 1994 ## 2 4 3 2 4 1 3 2 3 2 4 1 3 1 2 ## 1995 1996 1997 1998 1999 ## 4 1 3 6 1 # Partizipation am 21. Mai 2017 table(voto$part) ## ## 1 participated 2 did not participate ## 130 70 # Partizipation an 10 Abstimmungen table(voto$part2) ## ## 00 0 voting 01 02 03 04 ## 9 1 6 5 3 ## 05 06 07 08 09 ## 13 6 15 29 19 ## 10 10 votings 98 don&#39;t know ## 91 3 # Geschlecht table(voto$sex) ## ## 1 man 2 woman ## 93 107 Jetzt möchten wir diese Variablen aber vergleichen, nicht nur einzeln anschauen. # Vergleich Partizipation / Geschlecht table(voto$sex, voto$part) ## ## 1 participated 2 did not participate ## 1 man 63 30 ## 2 woman 67 40 table(voto$sex, voto$part2) ## ## 00 0 voting 01 02 03 04 05 06 07 08 09 10 10 votings ## 1 man 4 1 2 3 0 3 2 7 13 8 48 ## 2 woman 5 0 4 2 3 10 4 8 16 11 43 ## ## 98 don&#39;t know ## 1 man 2 ## 2 woman 1 Schon bei der zweiten Tabelle stossen wir aber auf Darstellungsprobleme - so viele Zahlen sind nicht mehr intuitiv vergleichbar. Vor allem, wenn wir jetzt beispielsweise das Geburtsjahr und die Partizipation an zehn Abstimmungen vergleichen würden. Um das zu ermöglichen, arbeiten wir nicht mehr mit Tabellen, sondern mit Visualisierungen. "],
["r-vis.html", "12 Daten visualisieren 12.1 Histogramme 12.2 Bar Graph 12.3 Scatterplot 12.4 Grafiken speichern 12.5 Zusammenfassung", " 12 Daten visualisieren Fünf verschiedene Visualisierungsmöglichkeiten werden wir heute kurz anschauen, die alle ein ganz anderes Ziel haben, um Daten darzustellen. 12.1 Histogramme Histogramme werden üblicherweise dazu genutzt, um Verteilung und Häufigkeit einer Variable aufzuzeigen, wie beispielsweise beim Geburtsjahr. Ein Histogramm ist für kontinuierliche Variablen geeignet. Für Grafiken verwenden wir die Package ggplot2. ggplot2 ist nach einem Muster aufgebaut, bei dem zuerst die Grafik per ggplot() initiiert wird und in einem nächsten Schritt die geometrische Struktur definiert wird (die erste Ebene, wo tatsächlich etwas dargestellt wird, im ersten Beispiel geom_histogram()). Entweder im ersten oder zweiten Befehl müssen wir dann die Daten sowie die Variablen definieren, welche die Darstellung bestimmen, hier also data=voto, aes(x=birthyear). aes steht dabei für “Ästethik”. Anschliessend können mit weiteren Befehlen Titel, Skalen, Farben etc ergänzt werden. ggplot(data=voto, aes(x=birthyear)) + geom_histogram(binwidth=5) Spezifisch bei einem Histogramm ist der Befehl binwidth=5, mit dem wir definieren, wie breit die Balken sind - in diesem Fall sind es jeweils fünf Jahre, die zusammengefasst werden. 12.2 Bar Graph Ein Bar Graph sieht zwar ähnlich wie ein Histogramm aus, zeigt aber Quantitäten von kategoriellen Variablen (Faktoren in R-Sprache). Ein visueller Unterschied ist, dass diese Balken einen Abstand haben, anders als beim Histogramm, wo diese aneinander “gebunden” sind, um die kontinuierliche Variable zu repräsentieren. Beispielsweise können wir so darstellen, wie viele der befragten Personen teilgenommen haben - eigentlich dieselbe Information wie aus table(voto$part), einfach intuitiver interpretierbar. ggplot(data=voto, aes(x=part)) + geom_bar() Natürlich ist es auch möglich, mehr als nur eine Variable darzustellen. Eine Variante ist, dieselbe Grafik pro Geschlechtskategorie zu wiederholen, oder mit unterschiedlichen Farben zu arbeiten: # Ein facet_wrap() macht mehrere Grafiken für alle Kategorien ggplot(data=voto, aes(x=part)) + geom_bar() + facet_wrap(~sex) # Mit fill=sex füllen wir die Balken nach Kategorie mit unt. Farben ggplot(data=voto, aes(x=part, fill=sex)) + geom_bar() # Zusätzlich führt position=&quot;dodge&quot; dazu, dass die Balken nebeneinander sind ggplot(data=voto, aes(x=part, fill=sex)) + geom_bar(position=&quot;dodge&quot;) Hier stellt sich immer die Frage, welche Variable wie dargestellt werden soll. Möglich wäre natürlich auch, das ganze umzudrehen, sodass der Anteil an Teilnehmende pro Geschlechtskategorie offensichtlicher ist: # Hier werden x und y getauscht # zusätzlich führt position=&quot;fill&quot; dazu, dass auf 1 normiert wird ggplot(data=voto, aes(x=sex, fill=part)) + geom_bar(position=&quot;fill&quot;) 12.3 Scatterplot Ein Scatterplot zeigt das Verhältnis zwischen zwei quantitativen (meist kontinuierlichen) Variablen an. Diese werden häufig genutzt um visuell festzustellen, ob ein Zusammenhang zwischen zwei Variablen bestehen könnte. Wollen wir einen Scatterplot darstellen, braucht es ebenfalls x (die erklärende Variable) und y (die zu erklärende Variable), sowie wiederum eine andere geometrische Form. Da die voto-Daten mit Textwerten anstatt mit numerischen Werten arbeiten, müssen wir die Variable part2 - die Partizipation an 10 Abstimmungen - kurz recodieren. Das machen wir hier in zwei Schritte: zuerst werden die Werte, welche als “weiss nicht” codiert sind, zu sogenannten NA recodiert. Anschliessend nutzen wir die ersten zwei Zahlen pro Wert als Zahlenwerte. # Hier wird die Variable voto$part2 neu bestimmt als NA, # falls die Bedingung in der eckigen Klammer zustimmt, # also falls der Wert der Variable bei 98 ist voto$part2[voto$part2==&quot;98 don&#39;t know&quot;] &lt;- NA # Anschliessend machen wir eine neue Variable voto$part10, welche # 1. numerisch ist per as.numeric(), # 2. einen Substring aus der alten Variable voto$part2 ist per substr(), # 3. wobei beim ersten Wert gestartet wird, und beim zweiten gestoppt voto$part10 &lt;- as.numeric(substr(voto$part2, start=1, stop=2)) table(voto$part10) ## ## 0 1 2 3 4 5 6 7 8 9 10 ## 9 1 6 5 3 13 6 15 29 19 91 summary(voto$part10) ## Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s ## 0.000 7.000 9.000 7.914 10.000 10.000 3 # Falls bei einem dieser Befehle Probleme auftauchen, kann per ?substr # die Hilfeseite aufgerufen werden Jetzt, da wir eine kontinuierliche Variable (das Geburtsjahr) und eine ordinale Variable (die Teilnahmehäufigkeit) haben, können wir diese zwei Werte auf einem Scatterplot darstellen. # Scatterplots bilden wir mit Punkten (geom_point()), welche x- und y-Wert annehmen ggplot(data=voto, aes(x=birthyear, y=part10)) + geom_point() Hier sehen wir jetzt vor allem ein Problem der Umfrageforschung: solche Umfragen nach Abstimmungen erreichen insbesondere Personen, die politisch interessiert sind, und deshalb häufig an Abstimmungen teilnehmen (viele Werte auf der y-Achse sind bei 10), oder dies zumindest in der Umfrage angeben, weil es sozial erwünscht ist, an Abstimmungen teilzunehmen. Wir überschätzen hier wahrscheinlich die tatsächliche Partizipation dieser Leute. Ausserdem haben wir das Problem, dass wir nicht genau wissen, ob die Punkte jeweils nur eine Person darstellen, oder beispielsweise mehrere. Zumindest dieses Problem können wir grafisch lösen, indem wir ein “Jitter” einfügen, der die Punkte per Zufall um den tatsächlichen Wert streut. # ein geom_jitter() statt geom_point() bringt Streuung rein ggplot(data=voto, aes(x=birthyear, y=part10)) + geom_jitter() Allerdings ist es immer noch schwierig, eine Tendenz aus dieser Grafik rauszulesen. Damit wir den Zusammenhang besser interpretieren können, ist es möglich, noch eine Regressionslinie einzufügen, welche einen bivariaten Zusammenhang darstellt. # Wir können direkt einen bivariaten Zusammenhang schätzen # Scatterplot ergänzt um eine lineare Regressionslinie ggplot(data=voto, aes(x=birthyear, y=part10)) + geom_jitter() + geom_smooth(method=&quot;lm&quot;) Tatsächlich sehen wir einen leicht negativen Zusammenhang - die Linie zeigt fällt bei jüngeren Jahrgängen. Auch diese sehr einfache Auswertung bestätigt wieder einmal, dass jüngere Stimmberechtigte tendenziell weniger häufig an Abstimmungen teilnehmen. Zuletzt können wir noch schauen, welche dieser Personen denn auch an der Abstimmung vom 21. Mai 2017 teilgenommen haben. Beispielsweise, indem wir erneut Farben reinbringen. # Nur bei den Punkten werden wir noch die Farbe reinbringen mit aes(color=part) ggplot(data=voto, aes(x=birthyear, y=part10)) + geom_jitter(aes(color=part)) + geom_smooth(method=&quot;lm&quot;) Und in einer letzten Variante interessiert uns noch, ob dieses Muster nach Geschlecht unterschiedlich ist. Dafür machen wir für Frauen und Männer je eine bivariate Regressionslinie. # Nur bei den Punkten werden wir noch die Farbe reinbringen mit aes(color=part) ggplot(data=voto, aes(x=birthyear, y=part10, color=part)) + geom_jitter() + geom_smooth(method=&quot;lm&quot;) 12.4 Grafiken speichern Sollen die Grafiken schliesslich gespeichert werden, bietet ggplot2 mit ggsave() einen einfachen Befehl an. Dieser Befehl nimmt als Normaleinstellung die letzte produzierte Grafik und speichert sie im aktuellen Arbeitsordner ab: ggsave(&quot;plottitle.pdf&quot;, # Dateiname der zu speichernden Grafik dpi=300, # Auflösung, von 72 (Minimum) bis 300 units=c(&quot;cm&quot;), # Genutzte Masse für Dateigrösse, cm/mm/in width=10, height=10) # Breite und Grösse der Grafik. 12.5 Zusammenfassung Daten können also aus vielen verschiedenen Blickwinkeln betrachtet und somit analysiert werden. Tabellen und Grafiken sind dabei erste Möglichkeiten, um grosse Datensätze - teilweise mit mehreren hundert Variablen und tausende Beobachtungen - in leichter zu interpretierende Informationen zu reduzieren. Im vorliegenden Fall war die Frage, ob junge Stimmberechtigte und Frauen tatsächlich weniger häufig an Volksabstimmungen teilnehmen. Verschiedene Antworten sind möglich: mit den Bar Charts haben wir gesehen, dass absolut betrachtet mehr Frauen teilnehmen als Männer. Wird allerdings nach Geschlecht geschaut, wie der Anteil ist, dann ist die Stimmbeteiligung bei Frauen vergleichsweise tiefer als bei Männer. mit dem Scatterplot haben wir Alter und Partizipationshäufigkeit verglichen. Obwohl die Daten mit Vorsicht zu geniessen sind, sehen wir eine Tendenz, dass die Beteiligung bei jüngeren Stimmberechtigten tiefer ist als bei älteren Stimmberechtigten. Dieser Effekt scheint vor allem bei Männer stark zu sein - bei den Frauen scheint der Zusammenhang weniger stark ausgeprägt zu sein, d.h. vor allem ältere Männer nehmen vergleichsweise häufiger teil. Allerdings können wir nicht immer davon ausgehen, dass Datensätze immer so bereitgestellt werden, dass diese direkt auswertbar sind. Deshalb geht es in den nächsten Teilen dieser kurzen Einführung um die Frage, wie Datensätze aufbereitet werden können. Dieser weniger interessante Teil ist dabei mindestens so wichtig wie die Analyse selber: sind die Daten nicht korrekt, beruhen die Auswertungen auf falschen Annahmen, sind Resultate vielleicht dem Zufall geschuldet, und geht viel Zeit verloren, weil die gesamte Arbeit wiederholt werden muss. "],
["r-daten.html", "13 Daten säubern 13.1 Datensätze laden 13.2 Beobachtungen und Variablen auswählen 13.3 Variablen bilden und recodieren 13.4 Daten gruppieren und zusammenfassen 13.5 Deskriptive Statistik 13.6 Übung", " 13 Daten säubern Nicht immer sind Datensätze eins zu eins verwendbar für statistische Auswertungen. Meist - wie auch beim Voto-Datensatz - müssen wir zuerst Variablen recodieren, um diese besser auswerten zu können, oder wollen neue Variablen bilden. Ein paar wichtige Befehle dafür werden in diesem Kapitel kurz vorgestellt. Dieses Kapitel folgt in etwa Chapter 3 des Buches R for Data Science 13.1 Datensätze laden Beginnen wir mit der Frage, wie wir überhaupt Daten in R reinladen können. Die Daten für die Grafiken wurden mit dem Befehl read.table() reingeladen, weil diese als .csv-File zur Verfügung standen. Teilweise müssen wir aber Textdateien, Excel-Files, Stata-Daten und viele weitere Varianten in R reinladen. Für fast alle Möglichkeiten gibt es auch spezifische Funktionen (beispielsweise ein read.dta() für Stata-Daten in der Package foreign), die mit einer Google-Suche zu finden sind. Bleiben wir aber bei der generelleren Variante, einer Tabelle mit Daten, wobei die Zellen beispielsweise mit Kommas, Strichpunkte oder Tabs getrennt sind. In diesem Fall können wir die Grundfunktion read.table() verwenden. voto &lt;- # vor dem Pfeil kommt wie üblich der Name des Objekts read.table(&quot;voto855_sample.csv&quot;, # Pfad zur Datei header = T, # falls im csv-File Variablennamen drin sind: T/TRUE sep = &quot;;&quot;, # wie sind die Zellen getrennt (separated)? stringsAsFactors = F, # Texte als Faktoren: F/FALSE fileEncoding=&quot;UTF-8&quot; # welche Textkodierung ) # Klammer nicht vergessen! Mit demselben Befehl können unterschiedlichste Datenfiles geöffnet werden. Grundsätzlich, falls unbekannt, lohnt es sich, den Datensatz zuerst mit einem Texteditor zu öffnen, um die Struktur zu sehen. Haben wir mit R gearbeitet und einen Datensatz so bearbeitet, wie wir ihn gebrauchen können, lohnt es sich, diese Daten auch neu abzuspeichern. Einerseits können wir wiederum ein csv-File abspeichern, wobei wir simultan mit write.table() vorgehen. Die andere Möglichkeit ist, alle Objekte, Funktionen etc., also die aktuelle Arbeitsumgebung wie in der Kachel “Environment” angezeigt, abzuspeichern. Dafür speichern wir die Daten als .RData-File ab. # csv-File schreiben, sodass dieses in Tabellenprogrammen geöffnet werden kann write.table( # da wir das ja extern machen, müssen wir kein Objekt bilden mit &lt;- voto, # welches Objekt soll abgespeichert werden? file=&quot;sample.csv&quot;, # wo soll das Objekt abgespeichert werden? sep=&quot;;&quot;, # wie sollen die Zellen getrennt werden? fileEncoding=&quot;UTF-8&quot; # welche Textkodierung ) # Klammer nicht vergessen! # .RData-Image speichern # speichert alles ab, nicht nur ein Objekt save.image(&quot;sample.RData&quot;) Wer auf der Suche nach noch mehr Möglichkeiten zum Einlesen von Daten ist, soll sich mit der Package tidyr vertraut machen. In dieser sind auch moderne Befehle drin, um Datensätze umzuformen/reshapen. 13.2 Beobachtungen und Variablen auswählen Nicht immer wollen wir alle Beobachtungen oder alle Variablen in einem Datensatz anschauen - wie bei den Grafiken, wo wir uns für vier Variablen interessiert haben. In dplyr gibt es mit den Befehlen filter() und select() intuitive Funktionen, um das durchzuführen. # filter() wählt Daten nach Bedingungen aus (rows) voto.frauen &lt;- filter(voto, sex==&quot;2 woman&quot;) voto.jungefrauen &lt;- filter(voto, sex==&quot;2 woman&quot;, birthyear&gt;1979) # select() wählt Variablen aus (cols) voto.partic &lt;- select(voto, personid_4, part, part2) # Variablen löschen voto.red &lt;- select(voto, -trust_1, -importance1, -value3, -value11) Dabei gibt es einige Operatoren, die wohl nicht unbekannt sind: &gt; ist grösser als, sowie &gt;= grösser gleich, &lt; ist kleiner als, sowie &lt;= kleiner gleich, == steht für “entspricht”, != wiederum steht für “enspricht nicht”. Kombiniert werden Bedingungen ebenfalls mit &amp; (und) sowie | (oder). Zuletzt gibt es noch eine spezielle Funktion, um NA, also Missings, zu finden. Mit is.na() und der Umkehrung !is.na() können wir fehlende Werte finden. Haben wir in einer Variable viele fehlende Beobachtungen (z.B. das Einkommen), können wir diese Beobachtungen ausschliessen, und dann Auswertungen mit den neuen, vollständigen Daten machen. Details könnt ihr rausfinden, indem ihr ?filter und ?select tippt. 13.3 Variablen bilden und recodieren Oft wollen wir Variablen so haben, dass sie für uns besser ausgewertet werden können. Beim Einstieg haben wir beispielsweise die Partizipation an zehn Abstimmungen als Zahlenwerte abgespeichert, damit wir diese in der Grafik einbinden können. Zusätzliche Beispiele, wieso Variablen recodiert oder neu gebildet werden, sind: eine Dummy-Variable mit ist/ist nicht, z.B. eine Variable für Frauen, die 1 ist, wenn die Beobachtung von einer Frau stammt, oder 0, wenn es ein Mann ist; eine Variable, welche das Alter anzeigt, statt das Geburtsjahr; eine Variable mit Alterskategorien, statt einem fortlaufenden Alter; weil wir andere Labels haben wollen, als solche, die in den Daten drin sind; und viele weitere Möglichkeiten. R bietet für jeden Geschmack Möglichkeiten, wie Variablen gebildet und recodiert werden können. Einige zentrale Beispiele sind im nächsten Code aufgezeigt: # Dummy-Variablen # Frau == 1 und Mann == 0 voto$frau &lt;- as.numeric(voto$sex == &quot;2 woman&quot;) # alle Frauen, welche mind. 7 Mal teilgenommen haben voto$frau.part &lt;- as.numeric(voto$sex == &quot;2 woman&quot; &amp; voto$part10 &gt;= 7) # oder wir wollen voto$part einfacher verwendbar machen, hat partizipiert == 1 voto$participated &lt;- as.numeric(voto$part == &quot;1 participated&quot;) # Berechnungen machen # Alter statt Geburtsjahr (präziser wäre, auch den Monat zu berücksichtigen) voto$age &lt;- 2017 - voto$birthyear # Grundsätzlich funktioniert R wie Algebra mit Platzhaltern, # das wäre also so etwas wie y = 2017 - x, # nur das y und x nicht nur einzelne Werte sind, sondern Vektoren mit n Werten # Kategorien bilden # per logische Bedingung voto$agecat &lt;- NA voto$agecat[voto$age &gt;= 18] &lt;- 1 voto$agecat[voto$age &gt; 35] &lt;- 2 voto$agecat[voto$age &gt; 50] &lt;- 3 voto$agecat[voto$age &gt; 65] &lt;- 4 # Variable per recode-Befehl neu formulieren voto$income &lt;- recode(voto$income, &quot;01 less than 2&#39;000 CHF&quot; = &quot;&lt;4&#39;000 CHF&quot;, &quot;02 2&#39;001-3&#39;000 CHF&quot; = &quot;&lt;4&#39;000 CHF&quot;, &quot;03 3&#39;001-4&#39;000 CHF&quot; = &quot;&lt;4&#39;000 CHF&quot;, &quot;04 4&#39;001-5&#39;000 CHF&quot; = &quot;4&#39;001-8&#39;000 CHF&quot;, &quot;05 5&#39;001-6&#39;000 CHF&quot; = &quot;4&#39;001-8&#39;000 CHF&quot;, &quot;06 6&#39;001-7&#39;000 CHF&quot; = &quot;4&#39;001-8&#39;000 CHF&quot;, &quot;07 7&#39;001-8&#39;000 CHF&quot; = &quot;4&#39;001-8&#39;000 CHF&quot;, &quot;08 8&#39;001-9&#39;000 CHF&quot; = &quot;8&#39;001-12&#39;000 CHF&quot;, &quot;09 9&#39;001-10&#39;000 CHF&quot; = &quot;8&#39;001-12&#39;000 CHF&quot;, &quot;10 10&#39;001-11&#39;000 CHF&quot; = &quot;8&#39;001-12&#39;000 CHF&quot;, &quot;11 11&#39;001-12&#39;000 CHF&quot; = &quot;8&#39;001-12&#39;000 CHF&quot;, &quot;12 12&#39;001-13&#39;000 CHF&quot; = &quot;&gt;12&#39;001 CHF&quot;, &quot;13 13&#39;001-14&#39;000 CHF&quot; = &quot;&gt;12&#39;001 CHF&quot;, &quot;14 14&#39;001-15&#39;000 CHF&quot; = &quot;&gt;12&#39;001 CHF&quot;, &quot;15 more than 15&#39;000 CHF&quot; = &quot;&gt;12&#39;001 CHF&quot;, &quot;98 don&#39;t know&quot; = NA_character_, &quot;99 no answer&quot; = NA_character_ ) Wenn wir jetzt die Variablen im Datensatz noch einmal anschauen, sehen wir auch, dass diese unterschiedliche “Typen” haben. Per str(voto) sehen wir nach den Variablennamen jeweils eine Abkürzung, welche uns angibt, was das für Variablen sind. Wichtige Abkürzungen sind: int für Integer, num für Numerisch, sowie dbl für reale Zahlen, was also jeweils Zahlen repräsentieren, chr steht für Textstrings, fctr für Faktoren mit verschiedenen Levels, also im Hintergrund eine Zahl, die ein Label hat, und viele weitere, beispielsweise für Daten, Zeit, und logische Werte, also TRUE und FALSE. Viele weitere Möglichkeiten bildet in dplyr der Befehl mutate(), auf den wir hier aber nicht näher eingehen werden. Mehr über ?mutate verrät die Hilfeseite. 13.4 Daten gruppieren und zusammenfassen Neben den bereits kennengelernten Möglichkeiten, Daten zusammenzufassen, bietet dplyr auch die Möglichkeit, mit dem Befehl summarize() zu Werten wie Mittelwert, Median, Quantile etc. zu kommen. Insbesondere in Zusammenarbeit mit group_by() ist dies ein sehr schneller Ansatz, um zu wichtigen deskriptiven Werten zu kommen. Hier kommen neu Ketten ins Spiel. Anstatt immer alle Zwischenschritte abzuspeichern, können wir die Resultate einer Berechnung direkt weiter verwenden. Um dies zu machen, verwenden wir die sogenannte Pipe, %&gt;%. Diese kann übrigens per Ctrl+Shift+M eingefügt werden. Grundsätzlich entspricht eine Pipe %&gt;% im Code etwa einem “und dann”. Zuerst gruppieren wir Daten, und dann werden diese zusammengefasst. In mathematischer Notation entsprechen x %&gt;% f(y) sowie f(x, y), wobei das Spiel noch weiter geführt werden kann. Aber direkt ein Beispiel: # Partizipation pro Altersgruppe und Geschlecht voto %&gt;% # nimm das Objekt voto und reiche es weiter zur nächsten Funktion group_by(agecat, frau) %&gt;% # gruppiere nach Alterskategorie, dann nach Frau summarize(mean=mean(participated)) # bilde ein Mittelwert der Partizipation ## # A tibble: 8 x 3 ## # Groups: agecat [?] ## agecat frau mean ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 0 0.5000000 ## 2 1 1 0.6666667 ## 3 2 0 0.6521739 ## 4 2 1 0.4800000 ## 5 3 0 0.5416667 ## 6 3 1 0.5862069 ## 7 4 0 0.8529412 ## 8 4 1 0.7500000 So haben wir jetzt den Mittelwert pro Alterskategorie nach Geschlecht, da wir zwei Funktionen miteinander verbinden konnten. Wenn wir möchten, können wir diese Werte auch als neues Objekt abspeichern und später weiterverwenden, beispielsweise in einer Grafik. Dann würden wir in der ersten Zeile einfach meanpart &lt;- voto %&gt;% ergänzen. Im summarize()-Befehl können wir auch mehrere Werte gleichzeitig berechnen. partsum &lt;- voto %&gt;% group_by(agecat, frau) %&gt;% summarize(mean=mean(participated), var=var(participated), cases=n()) partsum ## # A tibble: 8 x 5 ## # Groups: agecat [?] ## agecat frau mean var cases ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 1 0 0.5000000 0.2727273 12 ## 2 1 1 0.6666667 0.2333333 21 ## 3 2 0 0.6521739 0.2371542 23 ## 4 2 1 0.4800000 0.2600000 25 ## 5 3 0 0.5416667 0.2590580 24 ## 6 3 1 0.5862069 0.2512315 29 ## 7 4 0 0.8529412 0.1292335 34 ## 8 4 1 0.7500000 0.1935484 32 13.5 Deskriptive Statistik Neben der grafischen Auswertung von Variablen ist es in R natürlich auch möglich, statistische Masszahlen zu erhalten. Neben summarize() bietet uns R aber auch die Möglichkeit an, einzelne Zahlen direkt zu erhalten. # Mittelwert der Partizipation (=Stimmbeteiligung) mean(voto$participated, na.rm=T) ## [1] 0.65 # Median des Geburtsjahr median(voto$birthyear) ## [1] 1962 # Max und Min max(voto$birthyear) ## [1] 1999 min(voto$birthyear) ## [1] 1927 # Quantile quantile(voto$part10, c(0.1, 0.9), na.rm=T) ## 10% 90% ## 3 10 # Varianz und Standardabweichung var(voto$part10, na.rm=T) ## [1] 7.915985 sd(voto$part10, na.rm=T) ## [1] 2.813536 13.6 Übung Um die neu kennengelernten Befehle anzuwenden, wird folgende kurze Übung vorgeschlagen, welche den Start für die eigene Datenauswertung darstellt. Dabei kann auf die Unterlagen von der Einführung zurückgegriffen werden, wo alle notwendigen Befehle aufgeführt sind. Erstelle ein R-Script, in dem du alle Befehle dokumentierst und falls nötig auch kommentierst (mit einem # am Anfang der Linie). Hinweis: in RStudio oben links auf das Symbol mit dem weissen Papier und dem grünen Plus klicken. Von ILIAS den voto-Datensatz vom 21. Mai 2017 runterladen. In einem Ordner, das als ‘working directory’ dient abspeichern, und anschliessend in R laden. Hinweis: setwd() und read.table(). Anschliessend den Datensatz erkunden und gleichzeitig im Fragebogen (ebenfalls auf ILIAS) die Ausprägungen der Variablen überprüfen. Eine Variable auswählen, die genauer betrachtet werden soll. Den Datensatz auf die Variablen reduzieren, die wirklich interessieren, also die ausgewählte Variable und z.B. Abstimmungsentscheid, Partizipation, Alter oder Kanton, falls gewünscht auch eine Untergruppe definieren, die angeschaut werden soll. Eine Dummy- oder kategorielle Variable erstellen. Versuchen, diese Variable grafisch darzustellen, nach Möglichkeit auch mit einer zweiten Variable kombiniert. Kurz beantworten: wie könnte diese Grafik verbessert werden? Tipp: orientiere dich an den vorgestellten Grafiken. R-Script abspeichern, testen ob dieser ohne Fehler durchläuft. "],
["r-vis2.html", "14 Darstellung verfeinern 14.1 Achsen 14.2 Farben 14.3 Marker- und Linientypen 14.4 Beschriftungen 14.5 Themen 14.6 Übung", " 14 Darstellung verfeinern Obwohl ggplot2 in einem ersten Schritt viele Gestaltungsentscheidungen übernimmt, ist es teilweise nötig und/oder sinnvoll, selbst die Kontrolle über einige Darstellungen zu behalten. Einige wichtige Punkte sollen deshalb hier eingeführt werden. 14.1 Achsen ggplot2 ermöglicht, die Achsen und deren ‘Limits’ zu definieren, d.h. genau zu entscheiden, wie eine Achse aussehen soll. Aus der Einführung in Design und dem Argument der Ehrlichkeit einer Darstellung ist es sinnvoll, bei der y-Achse keine Trunkierung zu erlauben, da sonst Werte unterschätzt und Veränderungen überschätzt werden können. Der Befehl xlim() (oder auch ylim()) setzt zwei Werte als Grenzen der Skala: beispielsweise explizit auf 0, oder wenn man einen spezifischen Bereich genauer anschauen möchte. voto$part2[voto$part2==&quot;98 don&#39;t know&quot;] &lt;- NA voto$part10 &lt;- as.numeric(substr(voto$part2, start=1, stop=2)) ggplot(data=voto, aes(x=birthyear, y=part10)) + geom_point() + xlim(c(1980,2000)) Soll die y-Achse im Linechart noch genauer kontrolliert werden, kann auf die Skalen zurückgegriffen werden. Beispielsweise der Befehl scale_y_continuous: Im nächsten Plot werden folgende Veränderungen eingeführt: die Werte werden in Prozente umgewandelt y=part10/10, die Skala wird in Prozente angepasst labels=scales::percent_format(), und die Grenzen der y-Achse auf 0 und 1 festgelegt, sowie Beschriftungen in 0.2-Schritten eingefügt ('seq() liefert in diesem Fall automatisch c(0, 0.2, 0.4, 0.6, 0.8, 1) und verhindert so u.a. Tippfehler). ggplot(data=voto, aes(x=birthyear, y=part10/10)) + geom_point() + xlim(c(1960,2000)) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2), labels=scales::percent_format()) Darauf hinzuweisen ist, dass die korrekten Skalen verwendet werden müssen, da sonst ggplot2 die Werte falsch oder gar nicht interpretiert. Insbesondere verwendet werden kontinuierliche Skalen, diskrete Skalen, sowie Datumsskalen. Allerdings sind Skalen nicht nur für Achsen vorhanden, sondern auch für alle anderen Aesthetics. Insbesondere für Farben können diese sehr sinnvoll verwendet werden. 14.2 Farben Farben bedeutet in diesem Sinne nicht nur, eine Grafik farbenfroh machen zu können, sondern auch, diese in meist besser publizierbare Grautöne zu halten. Werden somit Farben über fill, color sowie alpha genutzt, können diese per Skala definiert werden. Ob color oder fill genutzt wird, ist abhängig vom Geom. Objekte mit einer Fläche wie beispielsweise in Balkendiagrammen oder Flächendiagrammen verwenden fill für den Inhalt und color für die Kontur. Die meisten anderen Objekte verwenden color. Die einfachste Variante, um Farben zu definieren, ist indem eine vordefinierte Palette an Farben genutzt wird. In der nächsten Grafik wird der Befehl scale_fill_brewer() dazu genutzt. ggplot(data=voto, aes(x=part, fill=sex)) + geom_bar() + scale_fill_brewer(palette=&quot;Dark2&quot;) Je nachdem welche Palette genutzt wird (siehe ?RColorBrewer) werden unterschiedliche Ziele erfüllt. Auch hier ist es relevant zu unterscheiden, ob kontinuierliche, divergierende oder kategorielle Skalen verwendet werden. Eine andere Variante als über Paletten ist es, die Farben direkt manuell zu bestimmen – wenn explizit definierte Farben verwendet werden sollen, welche eine gewisse Bedeutung haben (wie zum Beispiel Ja/Nein, Parteifarben, etc.). In dem Fall können Farben per scale_fill_manual() definiert werden. voto.party &lt;- filter(voto, party&lt;=&quot;10&quot;) ggplot(data=voto.party, aes(x=party, fill=party)) + geom_bar(position= &quot;identity&quot;) + scale_fill_manual(values = c(&quot;yellowgreen&quot;,&quot;firebrick&quot;, &quot;darkblue&quot;,&quot;orange&quot;, &quot;green4&quot;,&quot;lawngreen&quot;, &quot;gold&quot;,&quot;yellow&quot;,&quot;black&quot;)) + coord_flip() # Um die Labels besser zu sehen wird die Grafik gedreht Eine weitere Möglichkeit mit Farben zu arbeiten ist per Transparenz. Mit alpha lässt sich definieren, wie die Deckungskraft eines Objekts ist. Transparenz bietet sich beispielsweise bei Scatterplots mit vielen Beobachtungen als Alternative (oder Ergänzung) zu geom_jitter an – an Orten mit vielen Punkten wird die höhere Dichte an Beobachtungen auch durch stärkere Farben gesehen, da sich die Punkte überlappen, während einzelne Punkte weniger herausstechen. Ähnlich kann bei vielen Linien mit Transparenz gearbeitet werden. Nicht zuletzt kann alpha auch aus Designgründen gesetzt werden. Wichtig ist dabei, dass alpha nicht dazu genutzt werden sollte, Grafiken ‘unlesbar’ zu machen, da die Objekte nicht mehr vollständig sichtbar sind. ggplot(data=voto.party, aes(x=party, fill=party, alpha=part)) + geom_bar(position= &quot;fill&quot;) + coord_flip() + scale_fill_manual(values = c(&quot;yellowgreen&quot;,&quot;firebrick&quot;,&quot;darkblue&quot;,&quot;orange&quot;, &quot;green4&quot;,&quot;lawngreen&quot;,&quot;gold&quot;,&quot;yellow&quot;,&quot;black&quot;)) + scale_alpha_manual(values=c(0.3, 0.95)) 14.3 Marker- und Linientypen Ähnlich wie Farben können wir auch Darstellungsformen anpassen, d.h. das Aussehen von Punkten (shape) und Linien (linetype). Grundsätzlich gibt es hier zwei verschiedene Varianten, entweder indem eine Form fix definiert wird, oder indem eine Form als Aesthetic gesetzt wird, was zu unterschiedlichen Resultaten führt. ggplot(data=voto, aes(x=birthyear, y=part10, shape=as.factor(part), color=&quot;blue&quot;)) + geom_jitter() Wird mit einer Aesthetic (aes(color=as.factor(part))) gearbeitet, dann gibt es pro Kategorie/Gruppe eine andere Darstellung. Wird derselbe Befehl ausserhalb der aes() gesetzt, wird fix eine Variante gesetzt, beispielsweise mit aes(), color=&quot;blue&quot;. Je nachdem welches Ziel verfolgt werden soll, sind beide Befehle sinnvoll verwendbar. Weitere Informationen zu Shape und Linetype mit einer Übersicht der unterschiedlichen Formen. Sowohl für Farben wie auch für Markertypen und Linien gibt es sinnvollere und weniger sinnvollere Verwendungen. Noah Iliinsky hat eine kurze Übersicht zusammengestellt: Properties and Best Uses of Visual Encoding. 14.4 Beschriftungen Neben der Darstellung selbst können die Informationen auf einer Grafik ebenfalls per Text eingefügt werden. Insbesondere wenn Plots mehr oder weniger alleine stehen ist es notwendig, genügend Informationen mitzuliefern, damit die lesende Person auch ohne Begleittext die Grafik nachvollziehen kann (-&gt; Zugänglichkeit von Visualisierungen). Punkte, die eine Grafik begleiten sollten sind: Titel: Was wird in der Grafik gezeigt, für was stehen x- und y-Achse? Legende: Wie sind Farbe, Marker und Liniendicke zu decodieren? Lesehinweise bei unbekannteren Grafiken: Wie muss ich die Punkte, Linien und Strukturen interpretieren? Notiz zur weitergehenden Beschreibung: Habe ich Anpassungen an den Daten gemacht, welche bei der Interpretation berücksichtigt werden müssen, z.B. Outlier ausgeschlossen, Werte transformiert, etc.? Während die zwei ersten Punkte in jeder Grafik integriert werden sollten, können die zwei letzten Punkte auch im begleitenden Text erst hinzugefügt werden. Jede Grafik sollte über ein Titel verfügen. Je nach Gestaltung kann dieser zwar Teil der Beschriftung einer Grafik sein (im Sinne von ‘Grafik 1: Titel in Fett. Kommentar in normaler Schrift’), trotzdem ist es für eine schnelle Auffassung der Hauptaussage einer Grafik sinnvoll, einen Titel zu verwenden, der Teil der Grafik ist. Unabdingbar ist eine Beschriftung der Achsen, wobei es empfehlenswert ist, keine Variablennamen zu verwenden (allgemein ist es verständlicher, wenn im finalen Text nicht mit Codes à la logprctwrkagekat gearbeitet wird, sondern mit Klarnamen). Im nächsten Beispiel wird der labs()-Befehl eingeführt. ggplot(data=voto.party, aes(x=party, fill=party, alpha=part)) + geom_bar(position= &quot;fill&quot;) + coord_flip() + scale_fill_manual(values = c(&quot;yellowgreen&quot;,&quot;firebrick&quot;,&quot;darkblue&quot;,&quot;orange&quot;, &quot;green4&quot;,&quot;lawngreen&quot;,&quot;gold&quot;,&quot;yellow&quot;,&quot;black&quot;)) + scale_alpha_manual(values=c(0.3, 0.95)) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2), labels=scales::percent_format()) + labs(title=&quot;Partizipation nach Partei&quot;, subtitle=&quot;VOTO Studie zur Abstimmung vom 21. Mai 2017, Energiegesetz&quot;, x=&quot;Partei&quot;, y=&quot;&quot;, fill=&quot;Partei&quot;, alpha=&quot;Partizipation&quot;) Unschön in dieser Grafik ist jetzt noch, dass die Labels, die in den Daten drin sind, nicht wirklich gesäubert sind. Wir haben hier zwei Möglichkeiten, die Beschriftung der einzelnen Balken und der Legenden anzupassen: entweder, wir verändern die zu Grunde liegenden Daten und recodieren die einzelnen Variablen (was insbesondere sinnvoll ist, wenn wir dieselben Daten für verschiedene Grafiken verwenden). Oder, wenn wir die Daten in ihrem ursprünglichen Format behalten wollen, direkt für die Grafik ändern, indem wir die Skalenlabels definieren. Zusätzlich ist die Anordnung in der Variable part “verkehrt”, sodass wir diese ab sofort jeweils automatisch umkehren mit forcats::fct_rev(part). ggplot(data=voto.party, aes(x=party, fill=party, alpha=forcats::fct_rev(part))) + geom_bar(position= &quot;fill&quot;) + coord_flip() + scale_x_discrete(labels=c(&quot;SVP&quot;, &quot;SP&quot;, &quot;FDP&quot;, &quot;CVP&quot;, &quot;GPS&quot;, &quot;GLP&quot;, &quot;BDP&quot;, &quot;EVP&quot;, &quot;Lega&quot;)) + scale_fill_manual(values = c(&quot;yellowgreen&quot;,&quot;firebrick&quot;,&quot;darkblue&quot;,&quot;orange&quot;, &quot;green4&quot;,&quot;lawngreen&quot;,&quot;gold&quot;,&quot;yellow&quot;,&quot;black&quot;), labels=c(&quot;SVP&quot;, &quot;SP&quot;, &quot;FDP&quot;, &quot;CVP&quot;, &quot;GPS&quot;, &quot;GLP&quot;, &quot;BDP&quot;, &quot;EVP&quot;, &quot;Lega&quot;)) + scale_alpha_manual(values=c(0.3, 0.95), labels=c(&quot;nicht teilgenommen&quot;, &quot;teilgenommen&quot;)) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2), labels=scales::percent_format()) + labs(title=&quot;Partizipation nach Partei&quot;, subtitle=&quot;VOTO Studie zur Abstimmung vom 21. Mai 2017, Energiegesetz&quot;, x=&quot;Partei&quot;, y=&quot;&quot;, fill=&quot;Partei&quot;, alpha=&quot;Partizipation&quot;) Der Einfachheit halber können wir die Legende für die Farbe aber auch ausschalten (guides(fill=&quot;none&quot;)), da die Balken in diesem Fall ja beschriftet sind. Mit den gekürzten Labels können wir theoretisch auch wieder zur ungedrehten Variante der Grafik wechseln (ohne coord_flip()). Zusätzlich soll die Partizipationslegende an einem anderen Ort kommen (theme(legend.position=&quot;bottom&quot;). ggplot(data=voto.party, aes(x=party, fill=party, alpha=forcats::fct_rev(part))) + geom_bar(position= &quot;fill&quot;) + scale_x_discrete(labels=c(&quot;SVP&quot;, &quot;SP&quot;, &quot;FDP&quot;, &quot;CVP&quot;, &quot;GPS&quot;, &quot;GLP&quot;, &quot;BDP&quot;, &quot;EVP&quot;, &quot;Lega&quot;)) + scale_fill_manual(values = c(&quot;yellowgreen&quot;,&quot;firebrick&quot;,&quot;darkblue&quot;,&quot;orange&quot;, &quot;green4&quot;,&quot;lawngreen&quot;,&quot;gold&quot;,&quot;yellow&quot;,&quot;black&quot;)) + scale_alpha_manual(values=c(0.3, 0.95), labels=c(&quot;nicht teilgenommen&quot;, &quot;teilgenommen&quot;)) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2), labels=scales::percent_format()) + labs(title=&quot;Partizipation nach Partei&quot;, subtitle=&quot;VOTO Studie zur Abstimmung vom 21. Mai 2017, Energiegesetz&quot;, x=&quot;Partei&quot;, y=&quot;&quot;, fill=&quot;Partei&quot;, alpha=&quot;Partizipation&quot;) + guides(fill=&quot;none&quot;) + theme(legend.position=&quot;bottom&quot;) 14.5 Themen Letztens, ggplot2 bietet die Möglichkeit, mit vordefinierten Themen den Grundaufbau anzupassen, d.h., Farbschemas, Hintergründe, Schriftarten etc. anzupassen. Ein Beispiel ist theme_minimal(), das den unschönen grauen Hintergrund entfernt: ggplot(data=voto.party, aes(x=party, fill=party, alpha=forcats::fct_rev(part))) + geom_bar(position= &quot;fill&quot;) + scale_x_discrete(labels=c(&quot;SVP&quot;, &quot;SP&quot;, &quot;FDP&quot;, &quot;CVP&quot;, &quot;GPS&quot;, &quot;GLP&quot;, &quot;BDP&quot;, &quot;EVP&quot;, &quot;Lega&quot;)) + scale_fill_manual(values = c(&quot;yellowgreen&quot;,&quot;firebrick&quot;,&quot;darkblue&quot;,&quot;orange&quot;, &quot;green4&quot;,&quot;lawngreen&quot;,&quot;gold&quot;,&quot;yellow&quot;,&quot;black&quot;)) + scale_alpha_manual(values=c(0.3, 0.95), labels=c(&quot;nicht teilgenommen&quot;, &quot;teilgenommen&quot;)) + scale_y_continuous(limits=c(0,1), breaks=seq(0,1,0.2), labels=scales::percent_format()) + labs(title=&quot;Partizipation nach Partei&quot;, subtitle=&quot;VOTO Studie zur Abstimmung vom 21. Mai 2017, Energiegesetz&quot;, x=&quot;Partei&quot;, y=&quot;&quot;, fill=&quot;Partei&quot;, alpha=&quot;Partizipation&quot;) + guides(fill=&quot;none&quot;) + theme_minimal() + theme(legend.position=&quot;bottom&quot;) Mehr zu Themas findet sich auf der Webseite des Tidyversums. 14.6 Übung Erstelle eine Grafik und finalisiere diese, indem du auf Text, Farbe, etc. achtest. Führe anschliessend in Lauftextform (keine Stichwörter) aus, was in dieser Grafik zu lesen ist, und wie diese zu interpretieren ist. Es bietet sich an, mit dem Resultat der ersten Übung weiter zu arbeiten. "]
]
